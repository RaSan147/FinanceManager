class Goal {
    constructor(data, helpers) {
        this.data = data;
        this.helpers = helpers;
        this.currencySymbol = window.currencySymbols?.[this.data.currency] || window.currencySymbol || '$';
    }

    render() {
        const {
            safeDateString,
            fmt,
            cap,
            createEl,
            escapeHtml
        } = this.helpers;
        const g = this.data;
        const p = g.progress || {};
        const percent = Number(p.progress_percent || 0);
        const percentWidth = Math.max(0, Math.min(100, percent));
        const barClass = percent >= 75 ? 'bg-success' : percent >= 40 ? 'bg-warning' : 'bg-danger';
        const saved = p.current_amount ?? g.current_amount ?? 0;
        const target = g.target_amount || 0;
        const due = safeDateString(g.target_date);

        const item = createEl('div', {
            class: 'list-group-item',
            dataset: {
                goalId: g._id || g.id
            }
        });

        const top = createEl('div', {
            class: 'd-flex justify-content-between align-items-start'
        });
        const left = createEl('div');
        const right = createEl('div', {
            class: 'text-end goal-meta-block'
        });

        left.appendChild(createEl('h5', {
            class: 'mb-1'
        }, g.description || ''));

        const meta = createEl('div', {
            class: 'mb-1'
        });
        meta.appendChild(createEl('span', {
            class: 'badge ' + (g.is_completed ? 'bg-success' : 'bg-primary')
        }, g.type ? cap(g.type) : 'Goal'));
        meta.appendChild(createEl('span', {
            class: 'text-muted ms-2'
        }, `Target: ${this.currencySymbol}${fmt(target)}`));
        left.appendChild(meta);

        const dueEl = createEl('small', {
            class: 'text-muted'
        }, 'Due: ' + due);
        left.appendChild(dueEl);

        if (p.overdue_months) {
            left.appendChild(createEl('span', {
                class: 'badge bg-danger ms-1'
            }, `Overdue ${p.overdue_months} mo`));
        }

        const progBar = createEl('div', {
            class: 'progress-bar ' + barClass,
            style: `width: ${percentWidth}%`
        }, `${percent.toFixed(1)}%`);
        right.appendChild(createEl('div', {
            class: 'progress mb-1',
            style: 'height: 20px'
        }, progBar));

        const smallWrap = createEl('div', {
            class: 'small text-muted'
        });
        smallWrap.appendChild(createEl('div', {}, `Saved: ${this.currencySymbol}${fmt(saved)} / ${this.currencySymbol}${fmt(target)}`));
        if (p.required_monthly) {
            const reqText = `Req/mo: ${this.currencySymbol}${fmt(p.required_monthly)}`;
            const currentText = p.current_monthly ? ` | Current/mo: ${this.currencySymbol}${fmt(p.current_monthly)}` : '';
            smallWrap.appendChild(createEl('div', {}, reqText + currentText));
        }
        right.appendChild(smallWrap);

        top.appendChild(left);
        top.appendChild(right);
        item.appendChild(top);

        if (this.hasAiData(g)) {
            item.appendChild(this.renderAIBadges(g));
        }

            if (g.has_ai_plan || g.ai_plan || g.ai_plan_paste_url) {
            // New accordion (button + panel) replacing <details>/<summary>
            const accordion = createEl('div', { class: 'ai-plan-accordion mt-3' });
            const trigger = createEl('button', {
                type: 'button',
                class: 'ai-plan-trigger',
                'aria-expanded': 'false'
            }, [
                createEl('span', { class: 'ai-plan-trigger-chevron', 'aria-hidden': 'true' }),
                createEl('span', { class: 'ai-plan-trigger-label' }, 'AI Plan')
            ]);
            const planBody = createEl('div', { class: 'ai-plan-panel', hidden: '' });
            const scroller = createEl('div', { class: 'ai-plan-content' });
            // Render AI plan allowing a controlled subset of HTML tags generated by the AI.
            // If the plan contains no tag-like angle brackets, fall back to simple escaped + <br> newlines.
            const renderPlan = (raw)=>{
                if(!raw){ scroller.textContent=''; return; }
                const looksLikeHtml = /<\/?[a-zA-Z][^>]*>/.test(raw);
                if(!looksLikeHtml){
                    // Plain text: keep previous behavior
                    scroller.innerHTML = escapeHtml(raw).replace(/\n/g,'<br>');
                    return;
                }
                // Minimal sanitizer: allow only a safe whitelist of structural & formatting tags, strip others & all event handlers.
                const ALLOWED_TAGS = new Set(['DIV','P','UL','OL','LI','STRONG','EM','B','I','U','SPAN','BR','HR','H1','H2','H3','H4','H5','H6','TABLE','THEAD','TBODY','TR','TH','TD','CODE','PRE']);
                const ALLOWED_ATTR = new Set(['class','colspan','rowspan']); // restrict heavily
                const parser = new DOMParser();
                let doc;
                try { doc = parser.parseFromString('<div>'+raw+'</div>', 'text/html'); } catch(e){
                    scroller.innerHTML = escapeHtml(raw).replace(/\n/g,'<br>');
                    return;
                }
                const sanitizeNode = (node)=>{
                    if(node.nodeType === Node.ELEMENT_NODE){
                        if(!ALLOWED_TAGS.has(node.tagName)){
                            // Replace disallowed element with its children
                            const fragment = document.createDocumentFragment();
                            while(node.firstChild) fragment.appendChild(node.firstChild);
                            node.replaceWith(fragment);
                            return; // children already handled by move
                        } else {
                            // Strip disallowed attributes & any on* handlers
                            [...node.attributes].forEach(attr=>{
                                const name = attr.name.toLowerCase();
                                if(name.startsWith('on') || !ALLOWED_ATTR.has(name)) node.removeAttribute(attr.name);
                            });
                        }
                    }
                    let child = node.firstChild;
                    while(child){
                        const next = child.nextSibling;
                        sanitizeNode(child);
                        child = next;
                    }
                };
                const wrapper = doc.body.firstChild; // the injected <div>
                sanitizeNode(wrapper);
                scroller.innerHTML = wrapper.innerHTML; // safe version
            };
            // initial render if already present
            if(g.ai_plan) renderPlan(g.ai_plan);
            planBody.appendChild(scroller);
            accordion.appendChild(trigger);
            accordion.appendChild(planBody);
            async function ensurePlanLoaded(){
                if(scroller.dataset.loaded || g.ai_plan){ return; }
                // Fetch if offloaded OR local plan exists but was projected out (has_ai_plan flag)
                if((g.ai_plan_paste_url || g.has_ai_plan) && !g.ai_plan){
                    trigger.classList.add('loading');
                    try {
                        const resp = await fetch(`/api/goals/${g._id || g.id}/ai-plan`);
                        if(resp.ok){
                            const data = await resp.json();
                            if(data.plan){
                                g.ai_plan = data.plan; // cache locally in current session
                                renderPlan(g.ai_plan);
                                scroller.dataset.loaded='1';
                            } else {
                                scroller.innerHTML = '<div class="text-muted small">Plan not ready yet. Try again shortly.</div>';
                            }
                        }
                    } catch(e){ console.error('Failed to load AI plan', e); }
                    finally { trigger.classList.remove('loading'); }
                }
            }
            // Animation logic
            const openPanel = ()=>{
                trigger.setAttribute('aria-expanded','true');
                planBody.hidden = false;
                planBody.style.height = '0px';
                const h = scroller.scrollHeight + 12; // padding buffer
                requestAnimationFrame(()=>{
                    planBody.style.height = h + 'px';
                    planBody.classList.add('is-open');
                });
            };
            const closePanel = ()=>{
                trigger.setAttribute('aria-expanded','false');
                planBody.style.height = planBody.scrollHeight + 'px';
                requestAnimationFrame(()=>{
                    planBody.style.height = '0px';
                    planBody.classList.remove('is-open');
                });
            };
            planBody.addEventListener('transitionend', (e)=>{
                if(e.propertyName === 'height'){
                    if(trigger.getAttribute('aria-expanded')==='true'){
                        planBody.style.height = 'auto';
                    } else {
                        planBody.hidden = true;
                    }
                }
            });
            trigger.addEventListener('click', ()=>{
                const expanded = trigger.getAttribute('aria-expanded')==='true';
                // Close other open accordions within this goal item (single-open)
                item.querySelectorAll('.ai-plan-accordion .ai-plan-trigger[aria-expanded="true"]').forEach(btn=>{
                    if(btn!==trigger){
                        btn.setAttribute('aria-expanded','false');
                        const panel = btn.nextElementSibling;
                        if(panel && panel.classList.contains('ai-plan-panel')){
                            panel.style.height = panel.scrollHeight + 'px';
                            requestAnimationFrame(()=>{ panel.style.height = '0px'; panel.classList.remove('is-open'); });
                            panel.addEventListener('transitionend', (ev)=>{ if(ev.propertyName==='height' && btn.getAttribute('aria-expanded')==='false'){ panel.hidden = true; } }, { once: true });
                        }
                    }
                });
                if(expanded){
                    closePanel();
                } else {
                    ensurePlanLoaded().then(()=> openPanel());
                }
            });
            item.appendChild(accordion);
        }

        item.appendChild(this.renderActions(g));

        return item;
    }

    hasAiData(g) {
        return ['ai_priority', 'ai_urgency', 'ai_impact', 'ai_health_impact', 'ai_confidence'].some(k => g[k] != null) ||
            (g.ai_suggestions && g.ai_suggestions.length) ||
            g.ai_summary;
    }

    renderAIBadges(g) {
        const {
            createEl
        } = this.helpers;
        const wrap = createEl('div', {
            class: 'mt-2'
        });

        const addBadge = (cls, text) => {
            wrap.appendChild(createEl('span', {
                class: `badge ${cls} me-1`
            }, text));
        };

        if (g.ai_priority != null) addBadge('bg-info text-dark', `Priority ${Number(g.ai_priority).toFixed(0)}`);
        if (g.ai_urgency != null) addBadge('bg-warning text-dark', `Urgency ${Number(g.ai_urgency).toFixed(2)}`);
        if (g.ai_impact != null) addBadge('bg-success text-dark', `Impact ${Number(g.ai_impact).toFixed(2)}`);
        if (g.ai_health_impact != null && g.ai_health_impact > 0) addBadge('bg-danger text-dark', `Health ${Number(g.ai_health_impact).toFixed(2)}`);
        if (g.ai_confidence != null) addBadge('bg-secondary text-light', `Conf ${Number(g.ai_confidence).toFixed(2)}`);

        if (g.ai_suggestions && g.ai_suggestions.length) {
            const ul = createEl('ul', {
                class: 'mt-2 small'
            });
            g.ai_suggestions.forEach(s => ul.appendChild(createEl('li', {}, s)));
            wrap.appendChild(ul);
        }

        if (g.ai_summary) {
            wrap.appendChild(createEl('div', {
                class: 'small text-muted mt-1'
            }, g.ai_summary));
        }
        return wrap;
    }

    renderActions(g) {
        const {
            createEl
        } = this.helpers;
        const actions = createEl('div', {
            class: 'd-flex justify-content-end gap-2 mt-2'
        });

        if (!g.is_completed) {
            actions.appendChild(createEl('button', {
                class: 'btn btn-sm btn-outline-success action-btn',
                dataset: { goalComplete: g._id || g.id }
            }, 'Complete'));
            actions.appendChild(createEl('button', {
                class: 'btn btn-sm btn-outline-secondary action-btn',
                dataset: { goalRevalidate: g._id || g.id }
            }, 'Revalidate'));
            // Edit button (only for non-completed goals)
            actions.appendChild(createEl('button', {
                class: 'btn btn-sm btn-outline-primary action-btn',
                dataset: { goalEdit: g._id || g.id }
            }, 'Edit'));
        }
        actions.appendChild(createEl('button', {
            class: 'btn btn-sm btn-outline-danger action-btn',
            dataset: { goalDelete: g._id || g.id }
        }, 'Delete'));

        actions.addEventListener('click', e => {
            const target = e.target.closest('button');
            if (!target) return;
            const {
                goalComplete,
                goalRevalidate,
                goalDelete,
                goalEdit
            } = target.dataset;
            if (goalComplete) GoalsModule.doComplete(goalComplete);
            else if (goalRevalidate) GoalsModule.doRevalidate(goalRevalidate);
            else if (goalEdit) GoalsModule.openEditModal(goalEdit);
            else if (goalDelete) GoalsModule.doDelete(goalDelete);
        });

        return actions;
    }
}


class GoalsModule {
    static init(utils) {
        this.utils = utils;
        this.state = {
            page: 1,
            perPage: 5,
            total: 0,
            goalsMap: {}
        };
        if (this.utils.qs('[data-goals-root]')) {
            this.initGoalsPage();
        }
    }

    static initGoalsPage() {
        const { qs } = this.utils;
        const addForm = qs('[data-goal-form]');

        // Sort dropdown menu events
        const sortMenu = document.querySelector('[data-goals-sort-menu]');
        if (sortMenu) {
            sortMenu.addEventListener('click', e => {
                const a = e.target.closest('a[data-sort]');
                if (!a) return;
                e.preventDefault();
                const mode = a.getAttribute('data-sort');
                this.state.sort = mode;
                sortMenu.querySelectorAll('a[data-sort]').forEach(el => el.classList.remove('active'));
                a.classList.add('active');
                this.loadGoals(1);
            });
            const def = sortMenu.querySelector('a[data-sort="created_desc"]');
            def && def.classList.add('active');
        }
        if (!this.state.sort) this.state.sort = 'created_desc';

        // Remove local submit handler to avoid duplicate POST; global_modals handles creation.
        if (addForm) {
            addForm.addEventListener('submit', async (e) => {
                const fd = new FormData(addForm);
                const id = fd.get('_id');
                if (!id) return; // creation handled by global_modals.js
                e.preventDefault();
                if (addForm.dataset.submitting==='1') return; addForm.dataset.submitting='1';
                try {
                    const patchPayload = {
                        target_amount: fd.get('target_amount'),
                        description: fd.get('description'),
                        target_date: fd.get('target_date')
                    };
                    await this.utils.fetchJSON(`/api/goals/${id}`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(patchPayload)
                    });
                    window.flash && window.flash('Goal updated (AI revalidating...)', 'success');
                    this.closeModal();
                    this.loadGoals(this.state.page);
                } catch(err){
                    window.flash && window.flash('Update failed','danger');
                } finally { delete addForm.dataset.submitting; }
            }, { once: false });
        }

        qs('[data-goals-pagination]')?.addEventListener('click', e => {
            const a = e.target.closest('a[data-page]');
            if (!a) return;
            e.preventDefault();
            this.loadGoals(parseInt(a.dataset.page, 10));
        });

        qs('[data-open-goal-modal]')?.addEventListener('click', () => this.openAddModal());

        const modalEl = document.getElementById('goalModal');
        if (modalEl && window.bootstrap) {
            this.state.modal = window.bootstrap.Modal.getOrCreateInstance(modalEl);
        }

        this.loadGoals(1);

        // Listen for global goal creation events (in case creation happened before module fully ready or from another page/component)
        window.addEventListener('goal:created', () => {
            try { this.loadGoals(1); } catch(_) {}
        }, { passive: true });
    }

    static async loadGoals(page) {
        const {
            qs,
            fetchJSON
        } = this.utils;
        const root = qs('[data-goals-list]');
        if (!root) return;
        const perPage = parseInt(root.getAttribute('data-per-page') || '5', 10);
        const sortVal = this.state.sort || 'created_desc';

        try {
            const data = await fetchJSON(`/api/goals/list?page=${page}&per_page=${perPage}&sort=${encodeURIComponent(sortVal)}`);
            this.state.page = data.page;
            this.state.perPage = data.per_page;
            this.state.total = data.total;
            this.renderGoals(data.items || []);
            this.renderPagination();
            if (data.sort) this.state.sort = data.sort;
        } catch (e) {
            root.innerHTML = '<div class="text-danger">Failed to load goals</div>';
        }
    }

    static renderGoals(items) {
        const {
            qs
        } = this.utils;
        const root = qs('[data-goals-list]');
        if (!root) return;

        root.innerHTML = '';

    // Rebuild goals map for edit usage
    this.state.goalsMap = {};

        if (!items.length) {
            root.innerHTML = '<div class="text-center py-4 text-muted">No goals yet.</div>';
            return;
        }

        const frag = document.createDocumentFragment();
        items.forEach(itemData => {
            try {
                const gid = itemData._id || itemData.id;
                if (gid) this.state.goalsMap[gid] = itemData;
                const goal = new Goal(itemData, this.helpers());
                frag.appendChild(goal.render());
            } catch (e) {
                console.warn('Bad goal entry skipped', itemData, e);
            }
        });
        root.appendChild(frag);
    }


    static renderPagination() {
        const {
            qs,
            createEl
        } = this.utils;
        const wrap = qs('[data-goals-pagination]');
        if (!wrap) return;

        const totalPages = Math.ceil(this.state.total / this.state.perPage);
        wrap.innerHTML = '';
        if (totalPages <= 1) return;

        const ul = createEl('ul', {
            class: 'pagination justify-content-center mt-3'
        });

        const createPageItem = (text, page, isActive = false, isDisabled = false) => {
            const li = createEl('li', {
                class: `page-item ${isActive ? 'active' : ''} ${isDisabled ? 'disabled' : ''}`
            });
            const a = createEl('a', {
                class: 'page-link',
                href: '#',
                dataset: {
                    page
                }
            }, text);
            li.appendChild(a);
            return li;
        };

        if (this.state.page > 1) {
            ul.appendChild(createPageItem('Previous', this.state.page - 1));
        }

        for (let p = 1; p <= totalPages; p++) {
            ul.appendChild(createPageItem(p, p, p === this.state.page));
        }

        if (this.state.page < totalPages) {
            ul.appendChild(createPageItem('Next', this.state.page + 1));
        }

        wrap.appendChild(ul);
    }

    static async doComplete(id) {
        try {
            await this.utils.fetchJSON(`/api/goals/${id}/complete`, {
                method: 'POST'
            });
            window.flash && window.flash('Goal completed', 'success');
            this.loadGoals(this.state.page);
        } catch (err) {
            window.flash && window.flash('Complete failed', 'danger');
        }
    }

    static async doDelete(id) {
        if (!confirm('Are you sure you want to delete this goal?')) return;
        try {
            await this.utils.fetchJSON(`/api/goals/${id}`, {
                method: 'DELETE'
            });
            window.flash && window.flash('Goal deleted', 'success');
            this.loadGoals(this.state.page);
        } catch (err) {
            window.flash && window.flash('Delete failed', 'danger');
        }
    }

    static async doRevalidate(id) {
        try {
            await this.utils.fetchJSON(`/api/goals/${id}/revalidate`, {
                method: 'POST'
            });
            window.flash && window.flash('Revalidation started', 'info');
        } catch (err) {
            window.flash && window.flash('Revalidation failed', 'danger');
        }
    }

    static helpers() {
        return this.utils;
    }

    // ------------- Modal Helpers -------------
    static openAddModal() {
        // Delegate to global GoalModal if present to avoid duplicate logic
        if (window.GoalModal && typeof window.GoalModal.openCreate === 'function') {
            window.GoalModal.openCreate();
            return;
        }
        const { qs } = this.utils;
        const form = qs('[data-goal-form]');
        if (!form) return;
        form.reset();
        form.querySelector('[data-goal-id]').value = '';
        // Enable selects for add
        form.querySelector('[name="goal_type"]').disabled = false;
        form.querySelector('[name="target_currency"]').disabled = false;
        qs('[data-goal-modal-title]').textContent = 'Add Goal';
        const submitBtn = qs('[data-goal-submit-btn]');
        if (submitBtn) submitBtn.textContent = 'Save';
        this.updateCurrencySymbol();
        this.showModal();
    }

    static openEditModal(id) {
        const { qs } = this.utils;
        const goal = this.state.goalsMap[id];
        if (!goal) return;
        const form = qs('[data-goal-form]');
        if (!form) return;
    // Ensure modal exists (global include) and is appended once by global_modals.
        // Populate fields
        form.querySelector('[data-goal-id]').value = id;
        form.querySelector('[name="goal_type"]').value = goal.type || 'savings';
        form.querySelector('[name="goal_type"]').disabled = true; // not updatable via API
        form.querySelector('[name="target_amount"]').value = goal.target_amount;
        form.querySelector('[name="description"]').value = goal.description || '';
        try {
            const d = (goal.target_date || '').substring(0,10);
            form.querySelector('[name="target_date"]').value = d;
        } catch(e) {}
        form.querySelector('[name="target_currency"]').value = goal.currency;
    form.querySelector('[name="target_currency"]').disabled = true; // immutable during edit to avoid currency mismatch
        qs('[data-goal-modal-title]').textContent = 'Edit Goal';
        const submitBtn = qs('[data-goal-submit-btn]');
        if (submitBtn) submitBtn.textContent = 'Update';
        this.updateCurrencySymbol(goal.currency);
        this.showModal();
    }

    static updateCurrencySymbol(code) {
        const { qs } = this.utils;
        const symEl = qs('[data-goal-symbol-prefix]');
        if (!symEl) return;
    const currencySelect = qs('[name="target_currency"]');
    const c = code || (currencySelect ? currencySelect.value : null);
        if (!c) return;
        if (window.currencySymbols) {
            symEl.textContent = window.currencySymbols[c] || symEl.textContent;
        }
    }

    static showModal() {
        const el = document.getElementById('goalModal');
        if (!el) return;
        if (this.state.modal) {
            this.state.modal.show();
        } else {
            // Fallback manual show if bootstrap not found
            el.classList.add('show');
            el.style.display = 'block';
            el.removeAttribute('aria-hidden');
            el.setAttribute('aria-modal', 'true');
            el.setAttribute('role', 'dialog');
            // Ensure focus moves inside for accessibility
            setTimeout(() => {
                try { el.querySelector('input,select,textarea,button')?.focus(); } catch(_) {}
            }, 30);
        }
    }

    static closeModal() {
        const el = document.getElementById('goalModal');
        if (!el) return;
        if (this.state.modal) {
            this.state.modal.hide();
        } else {
            el.classList.remove('show');
            el.style.display = 'none';
            // Mirror bootstrap state when hidden
            el.setAttribute('aria-hidden', 'true');
            el.removeAttribute('aria-modal');
        }
    }
}

App.register(GoalsModule);

