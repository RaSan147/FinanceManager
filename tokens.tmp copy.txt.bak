Here is a coding project I am working on.
It starts with the full structure of the project, then you will have each file title and file content.

Respond with only 'OK' and for now, just understand the project completely.
I will ask for help in the next prompt so you can assist me with this project.



--- PROJECT STRUCTURE ---


{
    "FinanceManager/": {
        ".env": {},
        "app.py": {},
        "config.py": {},
        "requirements.txt": {},
        "models/": {
            "goal.py": {},
            "transaction.py": {},
            "user.py": {}
        },
        "__pycache__/": {},
        "static/": {
            "css/": {
                "style.css": {}
            },
            "js/": {
                "script.js": {}
            }
        },
        "templates/": {
            "add_transaction.html": {},
            "analysis.html": {},
            "base.html": {},
            "goals.html": {},
            "index.html": {},
            "login.html": {},
            "register.html": {},
            "transactions.html": {}
        },
        "utils/": {
            "ai_helper.py": {},
            "finance_calculator.py": {}
        }
    }
}


--- FILE : .env ---


--- FILE TOO LARGE / NO NEED TO READ ---


--- FILE : app.py ---


import os
from dotenv import load_dotenv
load_dotenv()

from flask import Flask, render_template, request, redirect, url_for, flash, jsonify
from flask_pymongo import PyMongo
from flask_bcrypt import Bcrypt
from flask_login import LoginManager, login_user, logout_user, login_required, current_user
from datetime import datetime, timedelta
from bson import ObjectId
import json
from models.user import User
from models.transaction import Transaction
from models.goal import Goal
from utils.ai_helper import get_ai_analysis, get_goal_plan
from utils.finance_calculator import calculate_monthly_summary, calculate_goal_progress
from config import Config

app = Flask(__name__)
app.config.from_object(Config)

mongo = PyMongo(app)
bcrypt = Bcrypt(app)

login_manager = LoginManager(app)
login_manager.login_view = 'login'

@app.context_processor
def inject_now():
    return {'now': datetime.utcnow()}

@login_manager.user_loader
def load_user(user_id):
    user_data = mongo.db.users.find_one({'_id': ObjectId(user_id)})
    if not user_data:
        return None
    return User(user_data)

# Custom JSON encoder to handle ObjectId and datetime
class JSONEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, ObjectId):
            return str(o)
        if isinstance(o, datetime):
            return o.isoformat()
        return json.JSONEncoder.default(self, o)

app.json_encoder = JSONEncoder

# Routes
@app.route('/')
@login_required
def index():
    # Get recent transactions
    recent_transactions = Transaction.get_recent_transactions(current_user.id, mongo.db)
    
    # Get active goals
    active_goals = Goal.get_active_goals(current_user.id, mongo.db)
    
    # Calculate monthly summary
    monthly_summary = calculate_monthly_summary(current_user.id, mongo.db)
    
    # Add progress to each goal
    for goal in active_goals:
        goal['progress'] = calculate_goal_progress(goal, monthly_summary)
    
    return render_template('index.html', 
                         transactions=recent_transactions,
                         goals=active_goals,
                         summary=monthly_summary)

@app.route('/login', methods=['GET', 'POST'])
def login():
    if current_user.is_authenticated:
        return redirect(url_for('index'))
    
    if request.method == 'POST':
        email = request.form.get('email')
        password = request.form.get('password')
        
        user_data = mongo.db.users.find_one({'email': email})
        if user_data and bcrypt.check_password_hash(user_data['password'], password):
            user = User(user_data)
            login_user(user)
            next_page = request.args.get('next')
            return redirect(next_page or url_for('index'))
        else:
            flash('Login failed. Check your email and password.', 'danger')
    
    return render_template('login.html', next=request.args.get('next'))

@app.route('/register', methods=['GET', 'POST'])
def register():
    if current_user.is_authenticated:
        return redirect(url_for('index'))
    
    if request.method == 'POST':
        email = request.form.get('email')
        password = request.form.get('password')
        name = request.form.get('name')
        
        if mongo.db.users.find_one({'email': email}):
            flash('Email already exists.', 'danger')
            return redirect(url_for('register'))
        
        hashed_password = bcrypt.generate_password_hash(password).decode('utf-8')
        
        user_data = {
            'email': email,
            'password': hashed_password,
            'name': name,
            'created_at': datetime.utcnow()
        }
        
        mongo.db.users.insert_one(user_data)
        flash('Account created successfully. Please login.', 'success')
        return redirect(url_for('login'))
    
    return render_template('register.html')

@app.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('login'))

# Transactions routes
@app.route('/transactions')
@login_required
def transactions():
    page = request.args.get('page', 1, type=int)
    per_page = 10
    
    transactions = Transaction.get_user_transactions(current_user.id, mongo.db, page, per_page)
    total_transactions = Transaction.count_user_transactions(current_user.id, mongo.db)
    
    return render_template('transactions.html', 
                         transactions=transactions,
                         page=page,
                         per_page=per_page,
                         total_transactions=total_transactions)

@app.route('/transactions/add', methods=['GET', 'POST'])
@login_required
def add_transaction():
    if request.method == 'POST':
        amount = float(request.form.get('amount'))
        transaction_type = request.form.get('type')
        category = request.form.get('category')
        description = request.form.get('description')
        date_str = request.form.get('date')
        related_person = request.form.get('related_person', '')
        
        try:
            date = datetime.strptime(date_str, '%Y-%m-%d')
        except ValueError:
            date = datetime.utcnow()
        
        transaction_data = {
            'user_id': current_user.id,
            'amount': amount,
            'type': transaction_type,
            'category': category,
            'description': description,
            'date': date,
            'related_person': related_person,
            'created_at': datetime.utcnow()
        }
        
        Transaction.create_transaction(transaction_data, mongo.db)
        flash('Transaction added successfully.', 'success')
        return redirect(url_for('transactions'))
    
    return render_template('add_transaction.html')

@app.route('/transactions/<transaction_id>/delete', methods=['POST'])
@login_required
def delete_transaction(transaction_id):
    Transaction.delete_transaction(current_user.id, ObjectId(transaction_id), mongo.db)
    flash('Transaction deleted successfully.', 'success')
    return redirect(url_for('transactions'))

# Goals routes
@app.route('/goals')
@login_required
def goals():
    goals = Goal.get_user_goals(current_user.id, mongo.db)
    
    # Calculate monthly summary for progress calculation
    monthly_summary = calculate_monthly_summary(current_user.id, mongo.db)
    
    # Add progress to each goal
    for goal in goals:
        goal['progress'] = calculate_goal_progress(goal, monthly_summary)
    
    return render_template('goals.html', goals=goals)

@app.route('/goals/add', methods=['POST'])
@login_required
def add_goal():
    goal_type = request.form.get('goal_type')
    target_amount = float(request.form.get('target_amount'))
    description = request.form.get('description')
    target_date_str = request.form.get('target_date')
    
    try:
        target_date = datetime.strptime(target_date_str, '%Y-%m-%d')
    except ValueError:
        target_date = datetime.utcnow() + timedelta(days=30)  # Default to 1 month
    
    goal_data = {
        'user_id': current_user.id,
        'type': goal_type,
        'target_amount': target_amount,
        'current_amount': 0.0,
        'description': description,
        'target_date': target_date,
        'created_at': datetime.utcnow(),
        'is_completed': False
    }
    
    goal_id = Goal.create_goal(goal_data, mongo.db)
    
    # Get AI plan for this goal
    user = mongo.db.users.find_one({'_id': ObjectId(current_user.id)})
    monthly_summary = calculate_monthly_summary(current_user.id, mongo.db)
    
    ai_plan = get_goal_plan(
        goal_type=goal_type,
        target_amount=target_amount,
        target_date=target_date,
        current_finances=monthly_summary,
        user_income=user.get('monthly_income', 0)
    )
    
    # Update goal with AI plan
    mongo.db.goals.update_one(
        {'_id': goal_id},
        {'$set': {'ai_plan': ai_plan}}
    )
    
    flash('Goal added successfully with AI plan.', 'success')
    return redirect(url_for('goals'))

@app.route('/goals/<goal_id>/complete', methods=['POST'])
@login_required
def complete_goal(goal_id):
    Goal.mark_as_completed(current_user.id, ObjectId(goal_id), mongo.db)
    flash('Goal marked as completed.', 'success')
    return redirect(url_for('goals'))

@app.route('/goals/<goal_id>/delete', methods=['POST'])
@login_required
def delete_goal(goal_id):
    Goal.delete_goal(current_user.id, ObjectId(goal_id), mongo.db)
    flash('Goal deleted successfully.', 'success')
    return redirect(url_for('goals'))

# Analysis routes
@app.route('/analysis')
@login_required
def analysis():
    monthly_summary = calculate_monthly_summary(current_user.id, mongo.db)
    goals = Goal.get_active_goals(current_user.id, mongo.db)
    
    # Calculate goal progress
    for goal in goals:
        goal['progress'] = calculate_goal_progress(goal, monthly_summary)
    
    # Get AI analysis
    user = mongo.db.users.find_one({'_id': ObjectId(current_user.id)})
    ai_analysis = get_ai_analysis(monthly_summary, goals, user)
    
    return render_template('analysis.html', 
                         summary=monthly_summary,
                         goals=goals,
                         ai_analysis=ai_analysis)

# API routes
@app.route('/api/transactions', methods=['GET'])
@login_required
def api_transactions():
    transactions = list(mongo.db.transactions.find({'user_id': current_user.id}).sort('date', -1))
    return jsonify(transactions)

@app.route('/api/summary', methods=['GET'])
@login_required
def api_summary():
    summary = calculate_monthly_summary(current_user.id, mongo.db)
    return jsonify(summary)

if __name__ == '__main__':
    app.run(debug=True)


--- FILE : config.py ---


import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    SECRET_KEY = os.getenv('SECRET_KEY', 'your-secret-key-here')
    MONGO_URI = os.getenv('MONGO_URI', 'mongodb://localhost:27017/finance_tracker')
    OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')


--- FILE : requirements.txt ---


flask
flask-pymongo
python-dotenv
google-genai
flask-bcrypt
flask-login
datetime


--- FILE : models/goal.py ---


from bson import ObjectId
from datetime import datetime

from bson import ObjectId
from datetime import datetime

class Goal:
    @staticmethod
    def create_goal(goal_data, db):
        return db.goals.insert_one(goal_data).inserted_id
    
    @staticmethod
    def get_user_goals(user_id, db):
        return list(db.goals.find({'user_id': user_id}).sort('target_date', 1))
    
    @staticmethod
    def get_active_goals(user_id, db):
        return list(db.goals.find({
            'user_id': user_id,
            'is_completed': False
        }).sort('target_date', 1))
    
    @staticmethod
    def mark_as_completed(user_id, goal_id, db):
        db.goals.update_one(
            {'_id': goal_id, 'user_id': user_id},
            {'$set': {'is_completed': True}}
        )
    
    @staticmethod
    def delete_goal(user_id, goal_id, db):
        db.goals.delete_one({'_id': goal_id, 'user_id': user_id})

    @staticmethod
    def calculate_progress(goal, current_savings):
        if goal['type'] == 'savings':
            # For savings goals, progress is based on accumulated savings
            progress_percent = min((current_savings / goal['target_amount']) * 100, 100)
            return {
                'progress_percent': round(progress_percent, 1),
                'current': current_savings,
                'required': goal['target_amount']
            }
        else:
            # For purchase goals, progress is based on accumulated savings
            progress_percent = min((current_savings / goal['target_amount']) * 100, 100)
            return {
                'progress_percent': round(progress_percent, 1),
                'current': current_savings,
                'required': goal['target_amount']
            }


--- FILE : models/transaction.py ---


from bson import ObjectId
from datetime import datetime

class Transaction:
    @staticmethod
    def create_transaction(transaction_data, db):
        return db.transactions.insert_one(transaction_data).inserted_id
    
    @staticmethod
    def get_user_transactions(user_id, db, page=1, per_page=10):
        skip = (page - 1) * per_page
        return list(db.transactions.find({'user_id': user_id})
                         .sort('date', -1)
                         .skip(skip)
                         .limit(per_page))
    
    @staticmethod
    def get_recent_transactions(user_id, db, limit=5):
        return list(db.transactions.find({'user_id': user_id})
                         .sort('date', -1)
                         .limit(limit))
    
    @staticmethod
    def count_user_transactions(user_id, db):
        return db.transactions.count_documents({'user_id': user_id})
    
    @staticmethod
    def delete_transaction(user_id, transaction_id, db):
        db.transactions.delete_one({'_id': transaction_id, 'user_id': user_id})


--- FILE : models/user.py ---


from bson import ObjectId
from flask_login import UserMixin

class User(UserMixin):
    def __init__(self, user_data):
        self.id = str(user_data['_id'])
        self.email = user_data['email']
        self.name = user_data.get('name', '')
        self.created_at = user_data.get('created_at')


--- FILE : static/css/style.css ---


body {
    background-color: #f8f9fa;
    padding-top: 20px;
}

.card {
    border-radius: 10px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    margin-bottom: 20px;
}

.card-header {
    border-radius: 10px 10px 0 0 !important;
}

.table th {
    border-top: none;
}

.progress {
    height: 25px;
    border-radius: 5px;
}

.progress-bar {
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
}

.list-group-item {
    margin-bottom: 10px;
    border-radius: 5px;
}

.accordion-button:not(.collapsed) {
    background-color: rgba(13, 110, 253, 0.1);
    color: #0d6efd;
}

.ai-analysis {
    background-color: #f8f9fa;
    padding: 15px;
    border-radius: 5px;
    border-left: 4px solid #0d6efd;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .card-body {
        padding: 15px;
    }
}


--- FILE : static/js/script.js ---


document.addEventListener('DOMContentLoaded', function() {
    // Initialize tooltips
    var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
    var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
        return new bootstrap.Tooltip(tooltipTriggerEl)
    });
    
    // Set today's date as default for date inputs
    var today = new Date().toISOString().split('T')[0];
    document.getElementById('date')?.setAttribute('value', today);
    document.getElementById('target_date')?.setAttribute('min', today);
    
    // Form validation
    var forms = document.querySelectorAll('.needs-validation');
    Array.prototype.slice.call(forms).forEach(function(form) {
        form.addEventListener('submit', function(event) {
            if (!form.checkValidity()) {
                event.preventDefault();
                event.stopPropagation();
            }
            form.classList.add('was-validated');
        }, false);
    });
});


--- FILE : utils/ai_helper.py ---


import json
import os
from google import genai
from google.genai import types

# Expect: export GEMINI_API_KEY="..."
client = genai.Client(api_key=os.environ["GEMINI_API_KEY"])

SYSTEM = {"role": "system", "content": "You are a helpful financial advisor."}
def default_serializer(obj):
    if hasattr(obj, 'isoformat'):
        return obj.isoformat()
    raise TypeError(f"Object of type {obj.__class__.__name__} is not JSON serializable")

def _make_gemini_response(prompt):
    # gemini-2.5-pro is highest quality but hits quota faster than flash models.
    resp = client.models.generate_content(
        model="gemini-2.5-pro",
        contents=prompt
    )
    return resp.text.strip()

def get_ai_analysis(monthly_summary, goals, user):
    user_name = user.get("name", "User")
    prompt = (
        f"You are a helpful financial advisor.\n\n"
        f"User: {user_name}\n"
        f"Monthly Income: ${monthly_summary['total_income']:,.2f}\n"
        f"Monthly Expenses: ${monthly_summary['total_expenses']:,.2f}\n"
        f"Monthly Savings: ${monthly_summary['savings']:,.2f}\n\n"
        f"Expense Categories:\n"
        f"{json.dumps(monthly_summary['expense_categories'], indent=2, default=default_serializer)}\n\n"
        f"Goals:\n"
        f"{json.dumps([{'description': g['description'], 'target_amount': g['target_amount'], 'target_date': g['target_date']} for g in goals], indent=2, default=default_serializer)}\n\n"
        "Provide a concise analysis of their financial health, spending patterns, and progress toward goals. "
        "Highlight any concerning patterns or opportunities for improvement. "
        "Offer 2-3 actionable recommendations."
    )
    return _make_gemini_response(prompt)

def get_goal_plan(goal_type, target_amount, target_date, current_finances, user_income):
    prompt = (
        f"You are a helpful financial planner.\n\n"
        f"Goal Type: {goal_type}\n"
        f"Target Amount: ${target_amount:,.2f}\n"
        f"Target Date: {target_date}\n\n"
        f"Current Financial Situation:\n"
        f"Monthly Income: ${user_income:,.2f}\n"
        f"Monthly Expenses: ${current_finances['total_expenses']:,.2f}\n"
        f"Monthly Savings: ${current_finances['savings']:,.2f}\n\n"
        f"Expense Breakdown:\n"
        f"{json.dumps(current_finances['expense_categories'], indent=2, default=default_serializer)}\n\n"
        "Provide a step-by-step plan to achieve this goal. Include:\n"
        "1. Required monthly savings 2. Potential areas to reduce spending 3. Timeline milestones 4. Tips to stay on track"
    )
    return _make_gemini_response(prompt)



--- FILE : utils/finance_calculator.py ---


from datetime import datetime, timedelta

def calculate_monthly_summary(user_id, db):
    # Get the first and last day of the current month
    today = datetime.utcnow()
    first_day = today.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    last_day = (first_day + timedelta(days=32)).replace(day=1) - timedelta(days=1)
    
    # Query transactions for this month
    transactions = list(db.transactions.find({
        'user_id': user_id,
        'date': {'$gte': first_day, '$lte': last_day}
    }))
    
    # Calculate totals
    total_income = 0
    total_expenses = 0
    expense_categories = {}
    income_categories = {}
    
    for t in transactions:
        if t['type'] == 'income':
            total_income += t['amount']
            income_categories[t['category']] = income_categories.get(t['category'], 0) + t['amount']
        else:
            total_expenses += t['amount']
            expense_categories[t['category']] = expense_categories.get(t['category'], 0) + t['amount']
    
    savings = total_income - total_expenses
    
    return {
        'month': first_day.strftime('%B %Y'),
        'total_income': total_income,
        'total_expenses': total_expenses,
        'savings': savings,
        'income_categories': income_categories,
        'expense_categories': expense_categories
    }

def calculate_goal_progress(goal, monthly_summary):
    if goal['type'] == 'savings':
        # For savings goals, progress is based on monthly savings
        remaining_months = max((goal['target_date'] - datetime.utcnow()).days / 30, 1)
        required_monthly = goal['target_amount'] / remaining_months
        current_monthly = monthly_summary['savings']
        progress = min((current_monthly / required_monthly) * 100, 100)
        return {
            'progress_percent': round(progress, 1),
            'current': current_monthly,
            'required': required_monthly
        }
    else:
        # For purchase goals, progress is based on accumulated savings
        progress = min((monthly_summary['savings'] / goal['target_amount']) * 100, 100)
        return {
            'progress_percent': round(progress, 1),
            'current': monthly_summary['savings'],
            'required': goal['target_amount']
        }


